#include <iostream>
#include <queue>
/*
생각정리
1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 
한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 
원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.
1.우선 n과 nl를 입력받는다.
2.1~n까지 반복문으로 queue에 입력한다.
변수선언이 필요하다. A:현재 남아있는 전체 원(N)의 수, 현재 A개 중에 몇 번째 위치에 있는지를 알려주는 int l를 선언한다. 
3-1. 처음에는 K번째 숫자를 pop한다. 단, 숫자를 지웠을 때 N(남아있는 숫자)의 값을 -1해준다. 또한 지운 숫자 바로 전 단계의 
위치에 현재 있으므로, 현재 값을 
K-1로 바꾸어야 한다.
3-2. 두번째 경우부터는 만약 l+a한 숫자가 A을 넘어간다면,  l=l+k-a를 지워주고 a-=1을 해준다.
이미 나온 값이 다음에 나오면 안된다면, bool visited[1000] ;와 같은 방식으로선언 만약 전역변수로 한다면 무조건 초기값은 0(false)임
vector에서 사이즈가 5인데 인덱스 3을 erase한다면, 중간에 사라지면서, 인덱스 4가 3으로 오게 되고
for문안에서는erase하면 위험한 이유:계속증가하는데 그 안에서 erase하면, erase하고 i--;를 해야 인덱스를 건너뛰지 않음 그래서 for보단 while을 추천함
만약 (1,2,3,5)가 되었다면 원래 인덱스 4번째는 접근 불가, segment
*/ 

using namespace std;

int main(void){
    
    return 0;
}